// Code generated by protoc-gen-go. DO NOT EDIT.
// source: raw.proto

package SC2APIProtocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type DisplayType int32

const (
	DisplayType_Visible  DisplayType = 1
	DisplayType_Snapshot DisplayType = 2
	DisplayType_Hidden   DisplayType = 3
)

var DisplayType_name = map[int32]string{
	1: "Visible",
	2: "Snapshot",
	3: "Hidden",
}
var DisplayType_value = map[string]int32{
	"Visible":  1,
	"Snapshot": 2,
	"Hidden":   3,
}

func (x DisplayType) Enum() *DisplayType {
	p := new(DisplayType)
	*p = x
	return p
}
func (x DisplayType) String() string {
	return proto.EnumName(DisplayType_name, int32(x))
}
func (x *DisplayType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DisplayType_value, data, "DisplayType")
	if err != nil {
		return err
	}
	*x = DisplayType(value)
	return nil
}
func (DisplayType) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

type Alliance int32

const (
	Alliance_Self    Alliance = 1
	Alliance_Ally    Alliance = 2
	Alliance_Neutral Alliance = 3
	Alliance_Enemy   Alliance = 4
)

var Alliance_name = map[int32]string{
	1: "Self",
	2: "Ally",
	3: "Neutral",
	4: "Enemy",
}
var Alliance_value = map[string]int32{
	"Self":    1,
	"Ally":    2,
	"Neutral": 3,
	"Enemy":   4,
}

func (x Alliance) Enum() *Alliance {
	p := new(Alliance)
	*p = x
	return p
}
func (x Alliance) String() string {
	return proto.EnumName(Alliance_name, int32(x))
}
func (x *Alliance) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Alliance_value, data, "Alliance")
	if err != nil {
		return err
	}
	*x = Alliance(value)
	return nil
}
func (Alliance) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

type CloakState int32

const (
	CloakState_Cloaked         CloakState = 1
	CloakState_CloakedDetected CloakState = 2
	CloakState_NotCloaked      CloakState = 3
)

var CloakState_name = map[int32]string{
	1: "Cloaked",
	2: "CloakedDetected",
	3: "NotCloaked",
}
var CloakState_value = map[string]int32{
	"Cloaked":         1,
	"CloakedDetected": 2,
	"NotCloaked":      3,
}

func (x CloakState) Enum() *CloakState {
	p := new(CloakState)
	*p = x
	return p
}
func (x CloakState) String() string {
	return proto.EnumName(CloakState_name, int32(x))
}
func (x *CloakState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CloakState_value, data, "CloakState")
	if err != nil {
		return err
	}
	*x = CloakState(value)
	return nil
}
func (CloakState) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

type StartRaw struct {
	MapSize          *Size2DI    `protobuf:"bytes,1,opt,name=map_size,json=mapSize" json:"map_size,omitempty"`
	PathingGrid      *ImageData  `protobuf:"bytes,2,opt,name=pathing_grid,json=pathingGrid" json:"pathing_grid,omitempty"`
	TerrainHeight    *ImageData  `protobuf:"bytes,3,opt,name=terrain_height,json=terrainHeight" json:"terrain_height,omitempty"`
	PlacementGrid    *ImageData  `protobuf:"bytes,4,opt,name=placement_grid,json=placementGrid" json:"placement_grid,omitempty"`
	PlayableArea     *RectangleI `protobuf:"bytes,5,opt,name=playable_area,json=playableArea" json:"playable_area,omitempty"`
	StartLocations   []*Point2D  `protobuf:"bytes,6,rep,name=start_locations,json=startLocations" json:"start_locations,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *StartRaw) Reset()                    { *m = StartRaw{} }
func (m *StartRaw) String() string            { return proto.CompactTextString(m) }
func (*StartRaw) ProtoMessage()               {}
func (*StartRaw) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

func (m *StartRaw) GetMapSize() *Size2DI {
	if m != nil {
		return m.MapSize
	}
	return nil
}

func (m *StartRaw) GetPathingGrid() *ImageData {
	if m != nil {
		return m.PathingGrid
	}
	return nil
}

func (m *StartRaw) GetTerrainHeight() *ImageData {
	if m != nil {
		return m.TerrainHeight
	}
	return nil
}

func (m *StartRaw) GetPlacementGrid() *ImageData {
	if m != nil {
		return m.PlacementGrid
	}
	return nil
}

func (m *StartRaw) GetPlayableArea() *RectangleI {
	if m != nil {
		return m.PlayableArea
	}
	return nil
}

func (m *StartRaw) GetStartLocations() []*Point2D {
	if m != nil {
		return m.StartLocations
	}
	return nil
}

type ObservationRaw struct {
	Player           *PlayerRaw `protobuf:"bytes,1,opt,name=player" json:"player,omitempty"`
	Units            []*Unit    `protobuf:"bytes,2,rep,name=units" json:"units,omitempty"`
	MapState         *MapState  `protobuf:"bytes,3,opt,name=map_state,json=mapState" json:"map_state,omitempty"`
	Event            *Event     `protobuf:"bytes,4,opt,name=event" json:"event,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *ObservationRaw) Reset()                    { *m = ObservationRaw{} }
func (m *ObservationRaw) String() string            { return proto.CompactTextString(m) }
func (*ObservationRaw) ProtoMessage()               {}
func (*ObservationRaw) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

func (m *ObservationRaw) GetPlayer() *PlayerRaw {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *ObservationRaw) GetUnits() []*Unit {
	if m != nil {
		return m.Units
	}
	return nil
}

func (m *ObservationRaw) GetMapState() *MapState {
	if m != nil {
		return m.MapState
	}
	return nil
}

func (m *ObservationRaw) GetEvent() *Event {
	if m != nil {
		return m.Event
	}
	return nil
}

type PowerSource struct {
	Pos              *Point   `protobuf:"bytes,1,opt,name=pos" json:"pos,omitempty"`
	Radius           *float32 `protobuf:"fixed32,2,opt,name=radius" json:"radius,omitempty"`
	Tag              *uint64  `protobuf:"varint,3,opt,name=tag" json:"tag,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *PowerSource) Reset()                    { *m = PowerSource{} }
func (m *PowerSource) String() string            { return proto.CompactTextString(m) }
func (*PowerSource) ProtoMessage()               {}
func (*PowerSource) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

func (m *PowerSource) GetPos() *Point {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *PowerSource) GetRadius() float32 {
	if m != nil && m.Radius != nil {
		return *m.Radius
	}
	return 0
}

func (m *PowerSource) GetTag() uint64 {
	if m != nil && m.Tag != nil {
		return *m.Tag
	}
	return 0
}

type PlayerRaw struct {
	PowerSources     []*PowerSource `protobuf:"bytes,1,rep,name=power_sources,json=powerSources" json:"power_sources,omitempty"`
	Camera           *Point         `protobuf:"bytes,2,opt,name=camera" json:"camera,omitempty"`
	UpgradeIds       []uint32       `protobuf:"varint,3,rep,name=upgrade_ids,json=upgradeIds" json:"upgrade_ids,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *PlayerRaw) Reset()                    { *m = PlayerRaw{} }
func (m *PlayerRaw) String() string            { return proto.CompactTextString(m) }
func (*PlayerRaw) ProtoMessage()               {}
func (*PlayerRaw) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{3} }

func (m *PlayerRaw) GetPowerSources() []*PowerSource {
	if m != nil {
		return m.PowerSources
	}
	return nil
}

func (m *PlayerRaw) GetCamera() *Point {
	if m != nil {
		return m.Camera
	}
	return nil
}

func (m *PlayerRaw) GetUpgradeIds() []uint32 {
	if m != nil {
		return m.UpgradeIds
	}
	return nil
}

type UnitOrder struct {
	AbilityId *uint32 `protobuf:"varint,1,opt,name=ability_id,json=abilityId" json:"ability_id,omitempty"`
	// Types that are valid to be assigned to Target:
	//	*UnitOrder_TargetWorldSpacePos
	//	*UnitOrder_TargetUnitTag
	Target           isUnitOrder_Target `protobuf_oneof:"target"`
	Progress         *float32           `protobuf:"fixed32,4,opt,name=progress" json:"progress,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *UnitOrder) Reset()                    { *m = UnitOrder{} }
func (m *UnitOrder) String() string            { return proto.CompactTextString(m) }
func (*UnitOrder) ProtoMessage()               {}
func (*UnitOrder) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{4} }

type isUnitOrder_Target interface {
	isUnitOrder_Target()
}

type UnitOrder_TargetWorldSpacePos struct {
	TargetWorldSpacePos *Point `protobuf:"bytes,2,opt,name=target_world_space_pos,json=targetWorldSpacePos,oneof"`
}
type UnitOrder_TargetUnitTag struct {
	TargetUnitTag uint64 `protobuf:"varint,3,opt,name=target_unit_tag,json=targetUnitTag,oneof"`
}

func (*UnitOrder_TargetWorldSpacePos) isUnitOrder_Target() {}
func (*UnitOrder_TargetUnitTag) isUnitOrder_Target()       {}

func (m *UnitOrder) GetTarget() isUnitOrder_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *UnitOrder) GetAbilityId() uint32 {
	if m != nil && m.AbilityId != nil {
		return *m.AbilityId
	}
	return 0
}

func (m *UnitOrder) GetTargetWorldSpacePos() *Point {
	if x, ok := m.GetTarget().(*UnitOrder_TargetWorldSpacePos); ok {
		return x.TargetWorldSpacePos
	}
	return nil
}

func (m *UnitOrder) GetTargetUnitTag() uint64 {
	if x, ok := m.GetTarget().(*UnitOrder_TargetUnitTag); ok {
		return x.TargetUnitTag
	}
	return 0
}

func (m *UnitOrder) GetProgress() float32 {
	if m != nil && m.Progress != nil {
		return *m.Progress
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UnitOrder) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _UnitOrder_OneofMarshaler, _UnitOrder_OneofUnmarshaler, _UnitOrder_OneofSizer, []interface{}{
		(*UnitOrder_TargetWorldSpacePos)(nil),
		(*UnitOrder_TargetUnitTag)(nil),
	}
}

func _UnitOrder_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UnitOrder)
	// target
	switch x := m.Target.(type) {
	case *UnitOrder_TargetWorldSpacePos:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TargetWorldSpacePos); err != nil {
			return err
		}
	case *UnitOrder_TargetUnitTag:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.TargetUnitTag))
	case nil:
	default:
		return fmt.Errorf("UnitOrder.Target has unexpected type %T", x)
	}
	return nil
}

func _UnitOrder_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UnitOrder)
	switch tag {
	case 2: // target.target_world_space_pos
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Point)
		err := b.DecodeMessage(msg)
		m.Target = &UnitOrder_TargetWorldSpacePos{msg}
		return true, err
	case 3: // target.target_unit_tag
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Target = &UnitOrder_TargetUnitTag{x}
		return true, err
	default:
		return false, nil
	}
}

func _UnitOrder_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*UnitOrder)
	// target
	switch x := m.Target.(type) {
	case *UnitOrder_TargetWorldSpacePos:
		s := proto.Size(x.TargetWorldSpacePos)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UnitOrder_TargetUnitTag:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.TargetUnitTag))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PassengerUnit struct {
	Tag              *uint64  `protobuf:"varint,1,opt,name=tag" json:"tag,omitempty"`
	Health           *float32 `protobuf:"fixed32,2,opt,name=health" json:"health,omitempty"`
	HealthMax        *float32 `protobuf:"fixed32,3,opt,name=health_max,json=healthMax" json:"health_max,omitempty"`
	Shield           *float32 `protobuf:"fixed32,4,opt,name=shield" json:"shield,omitempty"`
	Energy           *float32 `protobuf:"fixed32,5,opt,name=energy" json:"energy,omitempty"`
	UnitType         *uint32  `protobuf:"varint,6,opt,name=unit_type,json=unitType" json:"unit_type,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *PassengerUnit) Reset()                    { *m = PassengerUnit{} }
func (m *PassengerUnit) String() string            { return proto.CompactTextString(m) }
func (*PassengerUnit) ProtoMessage()               {}
func (*PassengerUnit) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{5} }

func (m *PassengerUnit) GetTag() uint64 {
	if m != nil && m.Tag != nil {
		return *m.Tag
	}
	return 0
}

func (m *PassengerUnit) GetHealth() float32 {
	if m != nil && m.Health != nil {
		return *m.Health
	}
	return 0
}

func (m *PassengerUnit) GetHealthMax() float32 {
	if m != nil && m.HealthMax != nil {
		return *m.HealthMax
	}
	return 0
}

func (m *PassengerUnit) GetShield() float32 {
	if m != nil && m.Shield != nil {
		return *m.Shield
	}
	return 0
}

func (m *PassengerUnit) GetEnergy() float32 {
	if m != nil && m.Energy != nil {
		return *m.Energy
	}
	return 0
}

func (m *PassengerUnit) GetUnitType() uint32 {
	if m != nil && m.UnitType != nil {
		return *m.UnitType
	}
	return 0
}

type Unit struct {
	// Fields are populated based on type/alliance
	DisplayType   *DisplayType `protobuf:"varint,1,opt,name=display_type,json=displayType,enum=SC2APIProtocol.DisplayType" json:"display_type,omitempty"`
	Alliance      *Alliance    `protobuf:"varint,2,opt,name=alliance,enum=SC2APIProtocol.Alliance" json:"alliance,omitempty"`
	Tag           *uint64      `protobuf:"varint,3,opt,name=tag" json:"tag,omitempty"`
	UnitType      *uint32      `protobuf:"varint,4,opt,name=unit_type,json=unitType" json:"unit_type,omitempty"`
	Owner         *int32       `protobuf:"varint,5,opt,name=owner" json:"owner,omitempty"`
	Pos           *Point       `protobuf:"bytes,6,opt,name=pos" json:"pos,omitempty"`
	Facing        *float32     `protobuf:"fixed32,7,opt,name=facing" json:"facing,omitempty"`
	Radius        *float32     `protobuf:"fixed32,8,opt,name=radius" json:"radius,omitempty"`
	BuildProgress *float32     `protobuf:"fixed32,9,opt,name=build_progress,json=buildProgress" json:"build_progress,omitempty"`
	Cloak         *CloakState  `protobuf:"varint,10,opt,name=cloak,enum=SC2APIProtocol.CloakState" json:"cloak,omitempty"`
	DetectRange   *float32     `protobuf:"fixed32,31,opt,name=detect_range,json=detectRange" json:"detect_range,omitempty"`
	RadarRange    *float32     `protobuf:"fixed32,32,opt,name=radar_range,json=radarRange" json:"radar_range,omitempty"`
	IsSelected    *bool        `protobuf:"varint,11,opt,name=is_selected,json=isSelected" json:"is_selected,omitempty"`
	IsOnScreen    *bool        `protobuf:"varint,12,opt,name=is_on_screen,json=isOnScreen" json:"is_on_screen,omitempty"`
	IsBlip        *bool        `protobuf:"varint,13,opt,name=is_blip,json=isBlip" json:"is_blip,omitempty"`
	// Not populated for snapshots
	Health          *float32 `protobuf:"fixed32,14,opt,name=health" json:"health,omitempty"`
	HealthMax       *float32 `protobuf:"fixed32,15,opt,name=health_max,json=healthMax" json:"health_max,omitempty"`
	Shield          *float32 `protobuf:"fixed32,16,opt,name=shield" json:"shield,omitempty"`
	Energy          *float32 `protobuf:"fixed32,17,opt,name=energy" json:"energy,omitempty"`
	MineralContents *int32   `protobuf:"varint,18,opt,name=mineral_contents,json=mineralContents" json:"mineral_contents,omitempty"`
	VespeneContents *int32   `protobuf:"varint,19,opt,name=vespene_contents,json=vespeneContents" json:"vespene_contents,omitempty"`
	IsFlying        *bool    `protobuf:"varint,20,opt,name=is_flying,json=isFlying" json:"is_flying,omitempty"`
	IsBurrowed      *bool    `protobuf:"varint,21,opt,name=is_burrowed,json=isBurrowed" json:"is_burrowed,omitempty"`
	// Not populated for enemies
	Orders             []*UnitOrder     `protobuf:"bytes,22,rep,name=orders" json:"orders,omitempty"`
	AddOnTag           *uint64          `protobuf:"varint,23,opt,name=add_on_tag,json=addOnTag" json:"add_on_tag,omitempty"`
	Passengers         []*PassengerUnit `protobuf:"bytes,24,rep,name=passengers" json:"passengers,omitempty"`
	CargoSpaceTaken    *int32           `protobuf:"varint,25,opt,name=cargo_space_taken,json=cargoSpaceTaken" json:"cargo_space_taken,omitempty"`
	CargoSpaceMax      *int32           `protobuf:"varint,26,opt,name=cargo_space_max,json=cargoSpaceMax" json:"cargo_space_max,omitempty"`
	BuffIds            []uint32         `protobuf:"varint,27,rep,name=buff_ids,json=buffIds" json:"buff_ids,omitempty"`
	AssignedHarvesters *int32           `protobuf:"varint,28,opt,name=assigned_harvesters,json=assignedHarvesters" json:"assigned_harvesters,omitempty"`
	IdealHarvesters    *int32           `protobuf:"varint,29,opt,name=ideal_harvesters,json=idealHarvesters" json:"ideal_harvesters,omitempty"`
	WeaponCooldown     *float32         `protobuf:"fixed32,30,opt,name=weapon_cooldown,json=weaponCooldown" json:"weapon_cooldown,omitempty"`
	EngagedTargetTag   *uint64          `protobuf:"varint,34,opt,name=engaged_target_tag,json=engagedTargetTag" json:"engaged_target_tag,omitempty"`
	XXX_unrecognized   []byte           `json:"-"`
}

func (m *Unit) Reset()                    { *m = Unit{} }
func (m *Unit) String() string            { return proto.CompactTextString(m) }
func (*Unit) ProtoMessage()               {}
func (*Unit) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{6} }

func (m *Unit) GetDisplayType() DisplayType {
	if m != nil && m.DisplayType != nil {
		return *m.DisplayType
	}
	return DisplayType_Visible
}

func (m *Unit) GetAlliance() Alliance {
	if m != nil && m.Alliance != nil {
		return *m.Alliance
	}
	return Alliance_Self
}

func (m *Unit) GetTag() uint64 {
	if m != nil && m.Tag != nil {
		return *m.Tag
	}
	return 0
}

func (m *Unit) GetUnitType() uint32 {
	if m != nil && m.UnitType != nil {
		return *m.UnitType
	}
	return 0
}

func (m *Unit) GetOwner() int32 {
	if m != nil && m.Owner != nil {
		return *m.Owner
	}
	return 0
}

func (m *Unit) GetPos() *Point {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Unit) GetFacing() float32 {
	if m != nil && m.Facing != nil {
		return *m.Facing
	}
	return 0
}

func (m *Unit) GetRadius() float32 {
	if m != nil && m.Radius != nil {
		return *m.Radius
	}
	return 0
}

func (m *Unit) GetBuildProgress() float32 {
	if m != nil && m.BuildProgress != nil {
		return *m.BuildProgress
	}
	return 0
}

func (m *Unit) GetCloak() CloakState {
	if m != nil && m.Cloak != nil {
		return *m.Cloak
	}
	return CloakState_Cloaked
}

func (m *Unit) GetDetectRange() float32 {
	if m != nil && m.DetectRange != nil {
		return *m.DetectRange
	}
	return 0
}

func (m *Unit) GetRadarRange() float32 {
	if m != nil && m.RadarRange != nil {
		return *m.RadarRange
	}
	return 0
}

func (m *Unit) GetIsSelected() bool {
	if m != nil && m.IsSelected != nil {
		return *m.IsSelected
	}
	return false
}

func (m *Unit) GetIsOnScreen() bool {
	if m != nil && m.IsOnScreen != nil {
		return *m.IsOnScreen
	}
	return false
}

func (m *Unit) GetIsBlip() bool {
	if m != nil && m.IsBlip != nil {
		return *m.IsBlip
	}
	return false
}

func (m *Unit) GetHealth() float32 {
	if m != nil && m.Health != nil {
		return *m.Health
	}
	return 0
}

func (m *Unit) GetHealthMax() float32 {
	if m != nil && m.HealthMax != nil {
		return *m.HealthMax
	}
	return 0
}

func (m *Unit) GetShield() float32 {
	if m != nil && m.Shield != nil {
		return *m.Shield
	}
	return 0
}

func (m *Unit) GetEnergy() float32 {
	if m != nil && m.Energy != nil {
		return *m.Energy
	}
	return 0
}

func (m *Unit) GetMineralContents() int32 {
	if m != nil && m.MineralContents != nil {
		return *m.MineralContents
	}
	return 0
}

func (m *Unit) GetVespeneContents() int32 {
	if m != nil && m.VespeneContents != nil {
		return *m.VespeneContents
	}
	return 0
}

func (m *Unit) GetIsFlying() bool {
	if m != nil && m.IsFlying != nil {
		return *m.IsFlying
	}
	return false
}

func (m *Unit) GetIsBurrowed() bool {
	if m != nil && m.IsBurrowed != nil {
		return *m.IsBurrowed
	}
	return false
}

func (m *Unit) GetOrders() []*UnitOrder {
	if m != nil {
		return m.Orders
	}
	return nil
}

func (m *Unit) GetAddOnTag() uint64 {
	if m != nil && m.AddOnTag != nil {
		return *m.AddOnTag
	}
	return 0
}

func (m *Unit) GetPassengers() []*PassengerUnit {
	if m != nil {
		return m.Passengers
	}
	return nil
}

func (m *Unit) GetCargoSpaceTaken() int32 {
	if m != nil && m.CargoSpaceTaken != nil {
		return *m.CargoSpaceTaken
	}
	return 0
}

func (m *Unit) GetCargoSpaceMax() int32 {
	if m != nil && m.CargoSpaceMax != nil {
		return *m.CargoSpaceMax
	}
	return 0
}

func (m *Unit) GetBuffIds() []uint32 {
	if m != nil {
		return m.BuffIds
	}
	return nil
}

func (m *Unit) GetAssignedHarvesters() int32 {
	if m != nil && m.AssignedHarvesters != nil {
		return *m.AssignedHarvesters
	}
	return 0
}

func (m *Unit) GetIdealHarvesters() int32 {
	if m != nil && m.IdealHarvesters != nil {
		return *m.IdealHarvesters
	}
	return 0
}

func (m *Unit) GetWeaponCooldown() float32 {
	if m != nil && m.WeaponCooldown != nil {
		return *m.WeaponCooldown
	}
	return 0
}

func (m *Unit) GetEngagedTargetTag() uint64 {
	if m != nil && m.EngagedTargetTag != nil {
		return *m.EngagedTargetTag
	}
	return 0
}

type MapState struct {
	Visibility       *ImageData `protobuf:"bytes,1,opt,name=visibility" json:"visibility,omitempty"`
	Creep            *ImageData `protobuf:"bytes,2,opt,name=creep" json:"creep,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *MapState) Reset()                    { *m = MapState{} }
func (m *MapState) String() string            { return proto.CompactTextString(m) }
func (*MapState) ProtoMessage()               {}
func (*MapState) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{7} }

func (m *MapState) GetVisibility() *ImageData {
	if m != nil {
		return m.Visibility
	}
	return nil
}

func (m *MapState) GetCreep() *ImageData {
	if m != nil {
		return m.Creep
	}
	return nil
}

type ActionRaw struct {
	// Types that are valid to be assigned to Action:
	//	*ActionRaw_UnitCommand
	//	*ActionRaw_CameraMove
	//	*ActionRaw_ToggleAutocast
	Action           isActionRaw_Action `protobuf_oneof:"action"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *ActionRaw) Reset()                    { *m = ActionRaw{} }
func (m *ActionRaw) String() string            { return proto.CompactTextString(m) }
func (*ActionRaw) ProtoMessage()               {}
func (*ActionRaw) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{8} }

type isActionRaw_Action interface {
	isActionRaw_Action()
}

type ActionRaw_UnitCommand struct {
	UnitCommand *ActionRawUnitCommand `protobuf:"bytes,1,opt,name=unit_command,json=unitCommand,oneof"`
}
type ActionRaw_CameraMove struct {
	CameraMove *ActionRawCameraMove `protobuf:"bytes,2,opt,name=camera_move,json=cameraMove,oneof"`
}
type ActionRaw_ToggleAutocast struct {
	ToggleAutocast *ActionRawToggleAutocast `protobuf:"bytes,3,opt,name=toggle_autocast,json=toggleAutocast,oneof"`
}

func (*ActionRaw_UnitCommand) isActionRaw_Action()    {}
func (*ActionRaw_CameraMove) isActionRaw_Action()     {}
func (*ActionRaw_ToggleAutocast) isActionRaw_Action() {}

func (m *ActionRaw) GetAction() isActionRaw_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ActionRaw) GetUnitCommand() *ActionRawUnitCommand {
	if x, ok := m.GetAction().(*ActionRaw_UnitCommand); ok {
		return x.UnitCommand
	}
	return nil
}

func (m *ActionRaw) GetCameraMove() *ActionRawCameraMove {
	if x, ok := m.GetAction().(*ActionRaw_CameraMove); ok {
		return x.CameraMove
	}
	return nil
}

func (m *ActionRaw) GetToggleAutocast() *ActionRawToggleAutocast {
	if x, ok := m.GetAction().(*ActionRaw_ToggleAutocast); ok {
		return x.ToggleAutocast
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ActionRaw) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ActionRaw_OneofMarshaler, _ActionRaw_OneofUnmarshaler, _ActionRaw_OneofSizer, []interface{}{
		(*ActionRaw_UnitCommand)(nil),
		(*ActionRaw_CameraMove)(nil),
		(*ActionRaw_ToggleAutocast)(nil),
	}
}

func _ActionRaw_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ActionRaw)
	// action
	switch x := m.Action.(type) {
	case *ActionRaw_UnitCommand:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UnitCommand); err != nil {
			return err
		}
	case *ActionRaw_CameraMove:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CameraMove); err != nil {
			return err
		}
	case *ActionRaw_ToggleAutocast:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ToggleAutocast); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ActionRaw.Action has unexpected type %T", x)
	}
	return nil
}

func _ActionRaw_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ActionRaw)
	switch tag {
	case 1: // action.unit_command
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ActionRawUnitCommand)
		err := b.DecodeMessage(msg)
		m.Action = &ActionRaw_UnitCommand{msg}
		return true, err
	case 2: // action.camera_move
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ActionRawCameraMove)
		err := b.DecodeMessage(msg)
		m.Action = &ActionRaw_CameraMove{msg}
		return true, err
	case 3: // action.toggle_autocast
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ActionRawToggleAutocast)
		err := b.DecodeMessage(msg)
		m.Action = &ActionRaw_ToggleAutocast{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ActionRaw_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ActionRaw)
	// action
	switch x := m.Action.(type) {
	case *ActionRaw_UnitCommand:
		s := proto.Size(x.UnitCommand)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ActionRaw_CameraMove:
		s := proto.Size(x.CameraMove)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ActionRaw_ToggleAutocast:
		s := proto.Size(x.ToggleAutocast)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ActionRawUnitCommand struct {
	AbilityId *int32 `protobuf:"varint,1,opt,name=ability_id,json=abilityId" json:"ability_id,omitempty"`
	// Types that are valid to be assigned to Target:
	//	*ActionRawUnitCommand_TargetWorldSpacePos
	//	*ActionRawUnitCommand_TargetUnitTag
	Target           isActionRawUnitCommand_Target `protobuf_oneof:"target"`
	UnitTags         []uint64                      `protobuf:"varint,4,rep,name=unit_tags,json=unitTags" json:"unit_tags,omitempty"`
	QueueCommand     *bool                         `protobuf:"varint,5,opt,name=queue_command,json=queueCommand" json:"queue_command,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *ActionRawUnitCommand) Reset()                    { *m = ActionRawUnitCommand{} }
func (m *ActionRawUnitCommand) String() string            { return proto.CompactTextString(m) }
func (*ActionRawUnitCommand) ProtoMessage()               {}
func (*ActionRawUnitCommand) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{9} }

type isActionRawUnitCommand_Target interface {
	isActionRawUnitCommand_Target()
}

type ActionRawUnitCommand_TargetWorldSpacePos struct {
	TargetWorldSpacePos *Point2D `protobuf:"bytes,2,opt,name=target_world_space_pos,json=targetWorldSpacePos,oneof"`
}
type ActionRawUnitCommand_TargetUnitTag struct {
	TargetUnitTag uint64 `protobuf:"varint,3,opt,name=target_unit_tag,json=targetUnitTag,oneof"`
}

func (*ActionRawUnitCommand_TargetWorldSpacePos) isActionRawUnitCommand_Target() {}
func (*ActionRawUnitCommand_TargetUnitTag) isActionRawUnitCommand_Target()       {}

func (m *ActionRawUnitCommand) GetTarget() isActionRawUnitCommand_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *ActionRawUnitCommand) GetAbilityId() int32 {
	if m != nil && m.AbilityId != nil {
		return *m.AbilityId
	}
	return 0
}

func (m *ActionRawUnitCommand) GetTargetWorldSpacePos() *Point2D {
	if x, ok := m.GetTarget().(*ActionRawUnitCommand_TargetWorldSpacePos); ok {
		return x.TargetWorldSpacePos
	}
	return nil
}

func (m *ActionRawUnitCommand) GetTargetUnitTag() uint64 {
	if x, ok := m.GetTarget().(*ActionRawUnitCommand_TargetUnitTag); ok {
		return x.TargetUnitTag
	}
	return 0
}

func (m *ActionRawUnitCommand) GetUnitTags() []uint64 {
	if m != nil {
		return m.UnitTags
	}
	return nil
}

func (m *ActionRawUnitCommand) GetQueueCommand() bool {
	if m != nil && m.QueueCommand != nil {
		return *m.QueueCommand
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ActionRawUnitCommand) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ActionRawUnitCommand_OneofMarshaler, _ActionRawUnitCommand_OneofUnmarshaler, _ActionRawUnitCommand_OneofSizer, []interface{}{
		(*ActionRawUnitCommand_TargetWorldSpacePos)(nil),
		(*ActionRawUnitCommand_TargetUnitTag)(nil),
	}
}

func _ActionRawUnitCommand_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ActionRawUnitCommand)
	// target
	switch x := m.Target.(type) {
	case *ActionRawUnitCommand_TargetWorldSpacePos:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TargetWorldSpacePos); err != nil {
			return err
		}
	case *ActionRawUnitCommand_TargetUnitTag:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.TargetUnitTag))
	case nil:
	default:
		return fmt.Errorf("ActionRawUnitCommand.Target has unexpected type %T", x)
	}
	return nil
}

func _ActionRawUnitCommand_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ActionRawUnitCommand)
	switch tag {
	case 2: // target.target_world_space_pos
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Point2D)
		err := b.DecodeMessage(msg)
		m.Target = &ActionRawUnitCommand_TargetWorldSpacePos{msg}
		return true, err
	case 3: // target.target_unit_tag
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Target = &ActionRawUnitCommand_TargetUnitTag{x}
		return true, err
	default:
		return false, nil
	}
}

func _ActionRawUnitCommand_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ActionRawUnitCommand)
	// target
	switch x := m.Target.(type) {
	case *ActionRawUnitCommand_TargetWorldSpacePos:
		s := proto.Size(x.TargetWorldSpacePos)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ActionRawUnitCommand_TargetUnitTag:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.TargetUnitTag))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ActionRawCameraMove struct {
	CenterWorldSpace *Point `protobuf:"bytes,1,opt,name=center_world_space,json=centerWorldSpace" json:"center_world_space,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ActionRawCameraMove) Reset()                    { *m = ActionRawCameraMove{} }
func (m *ActionRawCameraMove) String() string            { return proto.CompactTextString(m) }
func (*ActionRawCameraMove) ProtoMessage()               {}
func (*ActionRawCameraMove) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{10} }

func (m *ActionRawCameraMove) GetCenterWorldSpace() *Point {
	if m != nil {
		return m.CenterWorldSpace
	}
	return nil
}

type ActionRawToggleAutocast struct {
	AbilityId        *int32   `protobuf:"varint,1,opt,name=ability_id,json=abilityId" json:"ability_id,omitempty"`
	UnitTags         []uint64 `protobuf:"varint,2,rep,name=unit_tags,json=unitTags" json:"unit_tags,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ActionRawToggleAutocast) Reset()                    { *m = ActionRawToggleAutocast{} }
func (m *ActionRawToggleAutocast) String() string            { return proto.CompactTextString(m) }
func (*ActionRawToggleAutocast) ProtoMessage()               {}
func (*ActionRawToggleAutocast) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{11} }

func (m *ActionRawToggleAutocast) GetAbilityId() int32 {
	if m != nil && m.AbilityId != nil {
		return *m.AbilityId
	}
	return 0
}

func (m *ActionRawToggleAutocast) GetUnitTags() []uint64 {
	if m != nil {
		return m.UnitTags
	}
	return nil
}

type Event struct {
	DeadUnits        []uint64 `protobuf:"varint,1,rep,name=dead_units,json=deadUnits" json:"dead_units,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{12} }

func (m *Event) GetDeadUnits() []uint64 {
	if m != nil {
		return m.DeadUnits
	}
	return nil
}

func init() {
	proto.RegisterType((*StartRaw)(nil), "SC2APIProtocol.StartRaw")
	proto.RegisterType((*ObservationRaw)(nil), "SC2APIProtocol.ObservationRaw")
	proto.RegisterType((*PowerSource)(nil), "SC2APIProtocol.PowerSource")
	proto.RegisterType((*PlayerRaw)(nil), "SC2APIProtocol.PlayerRaw")
	proto.RegisterType((*UnitOrder)(nil), "SC2APIProtocol.UnitOrder")
	proto.RegisterType((*PassengerUnit)(nil), "SC2APIProtocol.PassengerUnit")
	proto.RegisterType((*Unit)(nil), "SC2APIProtocol.Unit")
	proto.RegisterType((*MapState)(nil), "SC2APIProtocol.MapState")
	proto.RegisterType((*ActionRaw)(nil), "SC2APIProtocol.ActionRaw")
	proto.RegisterType((*ActionRawUnitCommand)(nil), "SC2APIProtocol.ActionRawUnitCommand")
	proto.RegisterType((*ActionRawCameraMove)(nil), "SC2APIProtocol.ActionRawCameraMove")
	proto.RegisterType((*ActionRawToggleAutocast)(nil), "SC2APIProtocol.ActionRawToggleAutocast")
	proto.RegisterType((*Event)(nil), "SC2APIProtocol.Event")
	proto.RegisterEnum("SC2APIProtocol.DisplayType", DisplayType_name, DisplayType_value)
	proto.RegisterEnum("SC2APIProtocol.Alliance", Alliance_name, Alliance_value)
	proto.RegisterEnum("SC2APIProtocol.CloakState", CloakState_name, CloakState_value)
}

func init() { proto.RegisterFile("raw.proto", fileDescriptor5) }

var fileDescriptor5 = []byte{
	// 1509 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x5b, 0x73, 0x23, 0x47,
	0x15, 0xb6, 0x24, 0x4b, 0x96, 0x8e, 0xae, 0x69, 0xef, 0x65, 0x76, 0x9d, 0x25, 0x46, 0x81, 0xac,
	0x31, 0xb0, 0x01, 0x57, 0xa0, 0x8a, 0x2a, 0x08, 0xeb, 0xb5, 0x13, 0xa4, 0xaa, 0xec, 0x5a, 0xd5,
	0x72, 0xa0, 0x8a, 0x97, 0xa1, 0x3d, 0x7d, 0x3c, 0xea, 0xca, 0xa8, 0x67, 0xe8, 0x6e, 0x49, 0x51,
	0x5e, 0xf9, 0x1d, 0x3c, 0xf2, 0x3f, 0x78, 0xe4, 0x9d, 0x9f, 0x03, 0x0f, 0x54, 0xf7, 0xb4, 0x6e,
	0x96, 0xb5, 0xa6, 0x2a, 0x6f, 0x73, 0xbe, 0xf3, 0x9d, 0x9e, 0x73, 0xeb, 0x73, 0x1a, 0x6a, 0x8a,
	0xcd, 0x5e, 0x65, 0x2a, 0x35, 0x29, 0x69, 0x0d, 0x2f, 0xce, 0xce, 0x07, 0xfd, 0x81, 0x15, 0xa2,
	0x34, 0x79, 0xde, 0x88, 0xd2, 0xf1, 0x38, 0x95, 0xb9, 0xb6, 0xfb, 0xb7, 0x12, 0x54, 0x87, 0x86,
	0x29, 0x43, 0xd9, 0x8c, 0x9c, 0x41, 0x75, 0xcc, 0xb2, 0x50, 0x8b, 0xef, 0x30, 0x28, 0x1c, 0x17,
	0x4e, 0xea, 0x67, 0x4f, 0x5f, 0x6d, 0x5a, 0xbf, 0x1a, 0x8a, 0xef, 0xf0, 0xec, 0xb2, 0x4f, 0x0f,
	0xc6, 0x2c, 0xb3, 0xdf, 0xe4, 0xb7, 0xd0, 0xc8, 0x98, 0x19, 0x09, 0x19, 0x87, 0xb1, 0x12, 0x3c,
	0x28, 0x3a, 0xbb, 0x67, 0x77, 0xed, 0xfa, 0x63, 0x16, 0xe3, 0x25, 0x33, 0x8c, 0xd6, 0x3d, 0xfd,
	0x0f, 0x4a, 0x70, 0xf2, 0x1a, 0x5a, 0x06, 0x95, 0x62, 0x42, 0x86, 0x23, 0x14, 0xf1, 0xc8, 0x04,
	0xa5, 0x87, 0xec, 0x9b, 0xde, 0xa0, 0xe7, 0xf8, 0xf6, 0x84, 0x2c, 0x61, 0x11, 0x8e, 0x51, 0x9a,
	0xdc, 0x83, 0xfd, 0x07, 0x4f, 0x58, 0x1a, 0x38, 0x1f, 0x7e, 0x0f, 0x16, 0x98, 0xb3, 0x9b, 0x04,
	0x43, 0xa6, 0x90, 0x05, 0x65, 0x77, 0xc0, 0xf3, 0xbb, 0x07, 0x50, 0x8c, 0x0c, 0x93, 0x71, 0x82,
	0x7d, 0xda, 0x58, 0x18, 0x9c, 0x2b, 0x64, 0xe4, 0x35, 0xb4, 0xb5, 0x4d, 0x61, 0x98, 0xa4, 0x11,
	0x33, 0x22, 0x95, 0x3a, 0xa8, 0x1c, 0x97, 0xee, 0xcb, 0xde, 0x20, 0x15, 0xd2, 0x9c, 0x5d, 0xd2,
	0x96, 0xe3, 0x7f, 0xb5, 0xa0, 0x77, 0xff, 0x5d, 0x80, 0xd6, 0xd5, 0x8d, 0x46, 0x35, 0x75, 0x80,
	0xad, 0xc5, 0x2f, 0xa1, 0x62, 0x7f, 0x82, 0xca, 0x57, 0x62, 0x2b, 0x9e, 0x81, 0xd3, 0x52, 0x36,
	0xa3, 0x9e, 0x48, 0x4e, 0xa1, 0x3c, 0x91, 0xc2, 0xe8, 0xa0, 0xe8, 0xfe, 0xfe, 0xe8, 0xae, 0xc5,
	0xd7, 0x52, 0x18, 0x9a, 0x53, 0xc8, 0xaf, 0xa0, 0xe6, 0x4a, 0x6d, 0x98, 0x41, 0x9f, 0xf3, 0xe0,
	0x2e, 0xff, 0x2d, 0xcb, 0x86, 0x56, 0x4f, 0x6d, 0x57, 0xb8, 0x2f, 0xf2, 0x53, 0x28, 0xe3, 0x14,
	0xa5, 0xf1, 0x49, 0x7e, 0x7c, 0xd7, 0xe4, 0x0b, 0xab, 0xa4, 0x39, 0xa7, 0xfb, 0x17, 0xa8, 0x0f,
	0xd2, 0x19, 0xaa, 0x61, 0x3a, 0x51, 0x11, 0x92, 0x97, 0x50, 0xca, 0x52, 0xed, 0xc3, 0x79, 0x7c,
	0x6f, 0x6a, 0xa8, 0x65, 0x90, 0x27, 0x50, 0x51, 0x8c, 0x8b, 0x89, 0x76, 0xcd, 0x54, 0xa4, 0x5e,
	0x22, 0x1d, 0x28, 0x19, 0x16, 0x3b, 0x6f, 0xf7, 0xa9, 0xfd, 0xec, 0xfe, 0xbd, 0x00, 0xb5, 0x65,
	0x1e, 0xc8, 0x6b, 0x68, 0x66, 0xf6, 0x7f, 0xa1, 0x76, 0x3f, 0xb4, 0xbf, 0xb2, 0x79, 0x38, 0xda,
	0xfe, 0xd5, 0xd2, 0x29, 0xda, 0xc8, 0x56, 0x82, 0x26, 0x3f, 0x87, 0x4a, 0xc4, 0xc6, 0xa8, 0x98,
	0x6f, 0xe3, 0x1d, 0x5e, 0x7a, 0x12, 0xf9, 0x08, 0xea, 0x93, 0x2c, 0x56, 0x8c, 0x63, 0x28, 0xb8,
	0x0e, 0x4a, 0xc7, 0xa5, 0x93, 0x26, 0x05, 0x0f, 0xf5, 0xb9, 0xee, 0xfe, 0xab, 0x00, 0x35, 0x9b,
	0xf5, 0x2b, 0xc5, 0x51, 0x91, 0x17, 0x00, 0xec, 0x46, 0x24, 0xc2, 0xcc, 0x43, 0xc1, 0x5d, 0x1e,
	0x9a, 0xb4, 0xe6, 0x91, 0x3e, 0x27, 0x5f, 0xc1, 0x13, 0xc3, 0x54, 0x8c, 0x26, 0x9c, 0xa5, 0x2a,
	0xe1, 0xa1, 0xce, 0x58, 0x84, 0xa1, 0x4d, 0xd9, 0xfb, 0x9c, 0xe9, 0xed, 0xd1, 0xc3, 0xdc, 0xec,
	0x4f, 0xd6, 0x6a, 0x68, 0x8d, 0x06, 0xa9, 0x26, 0x27, 0xd0, 0xf6, 0xa7, 0xd9, 0x82, 0x87, 0xcb,
	0xc4, 0xf5, 0xf6, 0x68, 0x33, 0x57, 0x58, 0xc7, 0xae, 0x59, 0x4c, 0x9e, 0x43, 0x35, 0x53, 0x69,
	0xac, 0x50, 0x6b, 0x57, 0xd6, 0x22, 0x5d, 0xca, 0x6f, 0xaa, 0x50, 0xc9, 0xc9, 0xdd, 0x7f, 0x14,
	0xa0, 0x39, 0x60, 0x5a, 0xa3, 0x8c, 0x51, 0x59, 0xd3, 0x45, 0x39, 0x0a, 0xcb, 0x72, 0xd8, 0xc2,
	0x8d, 0x90, 0x25, 0x66, 0xb4, 0x28, 0x5c, 0x2e, 0xd9, 0xc0, 0xf3, 0xaf, 0x70, 0xcc, 0xbe, 0x75,
	0x6e, 0x14, 0x69, 0x2d, 0x47, 0xde, 0xb2, 0x6f, 0xad, 0x99, 0x1e, 0x09, 0x4c, 0xb8, 0xff, 0xbd,
	0x97, 0x2c, 0x8e, 0x12, 0x55, 0x3c, 0x77, 0x37, 0xb2, 0x48, 0xbd, 0x44, 0x8e, 0xa0, 0x96, 0xc7,
	0x34, 0xcf, 0x30, 0xa8, 0xb8, 0x34, 0x56, 0x2d, 0x70, 0x3d, 0xcf, 0xb0, 0xfb, 0xcf, 0x1a, 0xec,
	0x3b, 0xf7, 0x3e, 0x87, 0x06, 0x17, 0xda, 0x5e, 0x8d, 0x9c, 0x68, 0xfd, 0x6c, 0x6d, 0x37, 0xc3,
	0x65, 0xce, 0xb1, 0xb6, 0xb4, 0xce, 0x57, 0x02, 0xf9, 0x0c, 0xaa, 0x2c, 0x49, 0x04, 0x93, 0x11,
	0xba, 0x70, 0x5a, 0xdb, 0x17, 0xe4, 0xdc, 0xeb, 0xe9, 0x92, 0xb9, 0xdd, 0xa3, 0x9b, 0xde, 0xee,
	0x6f, 0x7a, 0x4b, 0x1e, 0x41, 0x39, 0x9d, 0x49, 0x54, 0x2e, 0xc2, 0x32, 0xcd, 0x85, 0xc5, 0x4d,
	0xa9, 0xfc, 0x3f, 0x37, 0xe5, 0x96, 0x45, 0x42, 0xc6, 0xc1, 0x41, 0x9e, 0xa1, 0x5c, 0x5a, 0xbb,
	0x41, 0xd5, 0x8d, 0x1b, 0xf4, 0x63, 0x68, 0xdd, 0x4c, 0x44, 0xc2, 0xc3, 0x65, 0xc1, 0x6b, 0x4e,
	0xdf, 0x74, 0xe8, 0xc0, 0x83, 0xe4, 0x17, 0x50, 0x8e, 0x92, 0x94, 0x7d, 0x13, 0x80, 0x8b, 0x7b,
	0x6b, 0x12, 0x5e, 0x58, 0x65, 0x3e, 0x1a, 0x72, 0x22, 0xf9, 0x21, 0x34, 0x38, 0x1a, 0x8c, 0x4c,
	0xa8, 0x98, 0x8c, 0x31, 0xf8, 0xc8, 0x1d, 0x5b, 0xcf, 0x31, 0x6a, 0x21, 0x7b, 0x59, 0x14, 0xe3,
	0x4c, 0x79, 0xc6, 0xb1, 0x63, 0x80, 0x83, 0x96, 0x04, 0xa1, 0x43, 0x8d, 0x09, 0x46, 0x06, 0x79,
	0x50, 0x3f, 0x2e, 0x9c, 0x54, 0x29, 0x08, 0x3d, 0xf4, 0x08, 0x39, 0x86, 0x86, 0xd0, 0x61, 0x2a,
	0x43, 0x1d, 0x29, 0x44, 0x19, 0x34, 0x16, 0x8c, 0x2b, 0x39, 0x74, 0x08, 0x79, 0x0a, 0x07, 0x42,
	0x87, 0x37, 0x89, 0xc8, 0x82, 0xa6, 0x53, 0x56, 0x84, 0x7e, 0x93, 0x88, 0x6c, 0xad, 0x33, 0x5b,
	0xef, 0xe9, 0xcc, 0xf6, 0xee, 0xce, 0xec, 0xec, 0xe8, 0xcc, 0x0f, 0x36, 0x3a, 0xf3, 0x27, 0xd0,
	0x19, 0x0b, 0x89, 0x8a, 0x25, 0x61, 0x94, 0x4a, 0x83, 0xd2, 0xe8, 0x80, 0xb8, 0xca, 0xb6, 0x3d,
	0x7e, 0xe1, 0x61, 0x4b, 0x9d, 0xa2, 0xce, 0x50, 0xe2, 0x8a, 0x7a, 0x98, 0x53, 0x3d, 0xbe, 0xa4,
	0x1e, 0x41, 0x4d, 0xe8, 0xf0, 0x36, 0x99, 0xdb, 0x42, 0x3f, 0x72, 0x71, 0x55, 0x85, 0xfe, 0xd2,
	0xc9, 0x3e, 0x6b, 0x37, 0x13, 0xa5, 0xd2, 0x19, 0xf2, 0xe0, 0xf1, 0x22, 0x27, 0x6f, 0x3c, 0x62,
	0x17, 0x49, 0x6a, 0xc7, 0x8f, 0x0e, 0x9e, 0xb8, 0x71, 0xf8, 0xec, 0xbe, 0xb5, 0xe0, 0x06, 0x14,
	0xf5, 0x44, 0xf2, 0x21, 0x00, 0xe3, 0xdc, 0x66, 0xda, 0xf6, 0xf2, 0x53, 0xd7, 0xcb, 0x55, 0xc6,
	0xf9, 0x95, 0xb4, 0xf3, 0xe2, 0x77, 0x00, 0xd9, 0x62, 0x10, 0xe8, 0x20, 0x70, 0x87, 0xbe, 0xd8,
	0x6a, 0xd2, 0xf5, 0x51, 0x41, 0xd7, 0x0c, 0xc8, 0x29, 0x7c, 0x10, 0x31, 0x15, 0xa7, 0x7e, 0xbe,
	0x19, 0xf6, 0x0d, 0xca, 0xe0, 0x59, 0x1e, 0xb9, 0x53, 0xb8, 0x11, 0x76, 0x6d, 0x61, 0xf2, 0x09,
	0xb4, 0xd7, 0xb9, 0xb6, 0x46, 0xcf, 0x1d, 0xb3, 0xb9, 0x62, 0xda, 0x3a, 0x3d, 0x83, 0xea, 0xcd,
	0xe4, 0xf6, 0xd6, 0x4d, 0xe1, 0x23, 0x37, 0x85, 0x0f, 0xac, 0xdc, 0xe7, 0x9a, 0x7c, 0x0a, 0x87,
	0x4c, 0x6b, 0x11, 0x4b, 0xe4, 0xe1, 0x88, 0xa9, 0x29, 0x6a, 0x63, 0xdd, 0xfe, 0xd0, 0x1d, 0x43,
	0x16, 0xaa, 0xde, 0x52, 0x63, 0x0b, 0x23, 0x38, 0xb2, 0x64, 0x9d, 0xfd, 0x22, 0x77, 0xcf, 0xe1,
	0x6b, 0xd4, 0x97, 0xd0, 0x9e, 0x21, 0xcb, 0x52, 0x19, 0x46, 0x69, 0x9a, 0xf0, 0x74, 0x26, 0x83,
	0x1f, 0xb8, 0x7e, 0x68, 0xe5, 0xf0, 0x85, 0x47, 0xc9, 0xcf, 0x80, 0xa0, 0x8c, 0x59, 0x8c, 0x3c,
	0xf4, 0x43, 0xd9, 0x26, 0xb6, 0xeb, 0x12, 0xdb, 0xf1, 0x9a, 0x6b, 0xa7, 0xb8, 0x66, 0x71, 0x77,
	0x0a, 0xd5, 0xc5, 0xea, 0x25, 0xbf, 0x01, 0x98, 0x0a, 0x2d, 0xf2, 0x25, 0xb1, 0xeb, 0x29, 0xb0,
	0x7a, 0xda, 0xac, 0x91, 0xc9, 0xa7, 0x50, 0xb6, 0xb7, 0x22, 0x7b, 0xf8, 0x49, 0x96, 0xf3, 0xba,
	0xff, 0x2d, 0x40, 0xed, 0x3c, 0x5a, 0x3c, 0x40, 0xfa, 0xd0, 0x70, 0x73, 0xcb, 0x3e, 0x17, 0x99,
	0xe4, 0xfe, 0xdf, 0x3f, 0xda, 0x9a, 0x81, 0x0b, 0x03, 0x5b, 0xe8, 0x8b, 0x9c, 0xdb, 0xdb, 0xa3,
	0xf5, 0xc9, 0x4a, 0x24, 0x5f, 0x42, 0x3d, 0xdf, 0x98, 0xe1, 0x38, 0x9d, 0xa2, 0xf7, 0xe7, 0xe3,
	0x9d, 0x27, 0x5d, 0x38, 0xee, 0xdb, 0x74, 0x8a, 0xbd, 0x3d, 0x0a, 0xd1, 0x52, 0x22, 0x14, 0xda,
	0x26, 0x8d, 0x63, 0xfb, 0x4e, 0x9b, 0x98, 0x34, 0x62, 0x7a, 0xf1, 0x5c, 0x7c, 0xb9, 0xf3, 0xac,
	0x6b, 0xc7, 0x3f, 0xf7, 0xf4, 0xde, 0x1e, 0x6d, 0x99, 0x0d, 0xc4, 0x6e, 0x38, 0xe6, 0xc8, 0xdd,
	0xff, 0x14, 0xe0, 0xd1, 0x7d, 0xd1, 0xdc, 0xb3, 0xb7, 0xcb, 0xeb, 0x7b, 0xfb, 0xdd, 0x03, 0x7b,
	0x7b, 0xd7, 0x2b, 0xf0, 0xfb, 0x6f, 0xee, 0xe5, 0x6a, 0x61, 0xb1, 0x5d, 0xdd, 0x25, 0x7b, 0x4d,
	0x27, 0xb9, 0x4e, 0x93, 0x8f, 0xa1, 0xf9, 0xd7, 0x09, 0x4e, 0x70, 0x59, 0xc0, 0xb2, 0x1b, 0x0d,
	0x0d, 0x07, 0xfa, 0xd0, 0xd6, 0xf6, 0xfb, 0x9f, 0xe1, 0xf0, 0x9e, 0x02, 0x90, 0x0b, 0x20, 0x11,
	0x4a, 0x83, 0x6a, 0x3d, 0xb8, 0xf7, 0xbf, 0xe1, 0x3a, 0xb9, 0xc1, 0x2a, 0xa8, 0xee, 0xd7, 0xf0,
	0x74, 0x47, 0x41, 0x1e, 0xca, 0xed, 0x46, 0x84, 0xc5, 0xcd, 0x08, 0xbb, 0x9f, 0x40, 0xd9, 0xbd,
	0x37, 0xed, 0x21, 0x1c, 0x19, 0x0f, 0xf3, 0xd7, 0x6f, 0xc1, 0xd1, 0x6a, 0x16, 0xb1, 0x89, 0xd2,
	0xa7, 0x9f, 0x41, 0x7d, 0x6d, 0xcb, 0x93, 0x3a, 0x1c, 0xfc, 0xd1, 0xde, 0x92, 0x04, 0x3b, 0x05,
	0xd2, 0x80, 0xea, 0x50, 0xb2, 0x4c, 0x8f, 0x52, 0xd3, 0x29, 0x12, 0x80, 0x4a, 0x4f, 0x70, 0x8e,
	0xb2, 0x53, 0x3a, 0xfd, 0x35, 0x54, 0x17, 0xfb, 0x9d, 0x54, 0x61, 0x7f, 0x88, 0xc9, 0x6d, 0xa7,
	0x60, 0xbf, 0xce, 0x93, 0x64, 0xde, 0x29, 0xda, 0x63, 0xde, 0xe1, 0xc4, 0x28, 0x96, 0x74, 0x4a,
	0xa4, 0x06, 0xe5, 0x2f, 0x24, 0x8e, 0xe7, 0x9d, 0xfd, 0xd3, 0xcf, 0x01, 0x56, 0xfb, 0xd1, 0xb2,
	0x9c, 0x84, 0xbc, 0x53, 0x20, 0x87, 0xd0, 0xf6, 0xc2, 0xa5, 0x5b, 0x8c, 0xc8, 0x3b, 0x45, 0xd2,
	0x02, 0x78, 0x97, 0x9a, 0x05, 0xa9, 0xf4, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x08, 0xb1, 0x4e,
	0xa8, 0xbb, 0x0d, 0x00, 0x00,
}
